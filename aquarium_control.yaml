blueprint:
  name: "Aquarium Smart Lighting Control"
  description: >
    Aquarium lighting control with power monitoring and brightness level control
    via button press simulation. Automatically detects current light level from
    power consumption with periodic validation.
    
    SETUP: Create input number helper for brightness control (min:0, max:3, step:1)
    then use this blueprint with your smart socket and power sensor.
  
  domain: automation
  
  input:
    aquarium_switch:
      name: "Aquarium Smart Socket"
      description: "Smart socket that controls the aquarium lights and monitors power consumption"
      selector:
        entity:
          domain: switch
    
    power_sensor:
      name: "Power Consumption Sensor"
      description: "Sensor that monitors the power consumption of the aquarium lights (usually from the smart socket)"
      selector:
        entity:
          domain: sensor
          device_class: power
    
    brightness_control:
      name: "Brightness Control Input"
      description: "Input number that controls light intensity (0=off, 1=low, 2=medium, 3=high). Create this in Helpers first."
      selector:
        entity:
          domain: input_number

variables:
  # Power thresholds (based on original Node-RED values)
  threshold_0: 0.5    # 0-0.5W = Level 0 (off)
  threshold_1: 5.0    # 0.5-5W = Level 1 (low)
  threshold_2: 9.0    # 6-9W = Level 2 (medium)
  threshold_3: 15.0   # 11-15W = Level 3 (high)
  
  # Timing configuration (all delays in milliseconds)
  initial_on_delay: 1000            # Wait after turning on before cycling starts
  cycle_off_delay: 500              # Wait after turning off during each cycle  
  cycle_on_delay: 500               # Wait after turning on during each cycle
  stabilization_delay: 5000         # Wait for light stabilization after all changes complete
  validation_quiet_period: 120000   # Milliseconds to wait after state change before allowing periodic validation (2 minutes)

trigger:
  # Power monitoring trigger
  - platform: state
    entity_id: !input power_sensor
    id: "power_changed"
  
  # Brightness control trigger with delay (for button simulation)
  # Note: This delay cannot use variables - must be hardcoded in trigger
  - platform: state
    entity_id: !input brightness_control
    for:
      seconds: 2
    id: "brightness_control_trigger"
  
  # Home Assistant start
  - platform: homeassistant
    event: start
    id: "ha_start"
  
  # Periodic validation (every minute) - validates state when no recent changes
  - platform: time_pattern
    minutes: "*"
    id: "periodic_validation"

condition: []

action:
  - variables:
      trigger_id: "{{ trigger.id | default('unknown') }}"
      brightness_input: !input brightness_control
      power_input: !input power_sensor  
      switch_input: !input aquarium_switch
      current_brightness: "{{ states(brightness_input) | float(0) }}"
      current_power: "{{ states(power_input) | float(0) }}"
      current_switch_state: "{{ states(switch_input) }}"

      # Create unique prefix for logging
      helper_prefix: "{{ switch_input.split('.')[1] }}"
      
      # Use this automation's last_triggered to determine quiet period
      # If automation never ran button simulation, allow validation immediately
      last_automation_run: "{{ this.attributes.last_triggered if this.attributes.last_triggered else '1970-01-01T00:00:00+00:00' }}"
      time_since_last_run: >
        {% set last_run = as_timestamp(last_automation_run) %}
        {% set now_time = now().timestamp() %}
        {{ ((now_time - last_run) * 1000) | int }}
      
      # Always estimate level from power reading - no persistent state needed
      current_level: >
        {% if current_switch_state == 'off' %}
          0
        {% elif current_power >= 0 and current_power <= (threshold_0 | float) %}
          0
        {% elif current_power > (threshold_0 | float) and current_power <= (threshold_1 | float) %}
          1
        {% elif current_power > (threshold_1 | float) and current_power <= (threshold_2 | float) %}
          2
        {% elif current_power > (threshold_2 | float) and current_power <= (threshold_3 | float) %}
          3
        {% else %}
          3
        {% endif %}

  # TRACE: Log every automation trigger
  - service: system_log.write
    data:
      message: "{{ helper_prefix }}: AUTOMATION TRIGGERED - ID: {{ trigger_id }}, Brightness: {{ current_brightness }}, Power: {{ current_power }}W, Switch: {{ current_switch_state }}, Current Level: {{ current_level }}"
      level: info

  # Route to appropriate logic based on trigger
  - choose:
      # INITIALIZATION - Log current state detected from power reading
      - conditions:
          - condition: template
            value_template: "{{ trigger_id == 'ha_start' }}"
        sequence:
          - service: system_log.write
            data:
              message: "{{ helper_prefix }}: INITIALIZATION - Current state detected: Level {{ current_level }} from {{ current_power }}W"
              level: warning



      # POWER MONITORING (from Node-RED power sensor logic)
      - conditions:
          - condition: template
            value_template: "{{ trigger_id in ['power_changed', 'ha_start'] }}"
        sequence:
          - service: system_log.write
            data:
              message: "{{ helper_prefix }}: POWER MONITORING TRIGGERED - Power: {{ current_power }}W, Input: {{ current_brightness }}, Current Level: {{ current_level }}"
              level: info
          - variables:
              detected_brightness: >
                {% if current_power >= 0 and current_power < threshold_0 %}
                  0
                {% elif current_power >= threshold_0 and current_power <= threshold_1 %}
                  1
                {% elif current_power > threshold_1 and current_power <= threshold_2 %}
                  2
                {% elif current_power > threshold_2 and current_power <= threshold_3 %}
                  3
                {% else %}
                  null
                {% endif %}
          
          - service: system_log.write
            data:
              message: "{{ helper_prefix }}: POWER ANALYSIS - {{ current_power }}W detected as level {{ detected_brightness }}, current setting: {{ current_brightness }}"
              level: info
          
          - condition: template
            value_template: "{{ detected_brightness is not none and detected_brightness != current_brightness }}"
          
          - service: system_log.write
            data:
              message: "{{ helper_prefix }}: BRIGHTNESS MISMATCH - Power {{ current_power }}W=Level{{ detected_brightness }}, Input={{ current_brightness }}, Current Level={{ current_level }}"
              level: warning
          
          # DISABLED: Auto-update of brightness input to prevent feedback loops
          # - service: input_number.set_value
          #   target:
          #     entity_id: !input brightness_control
          #   data:
          #     value: "{{ detected_brightness }}"
          
          - service: system_log.write
            data:
              message: "{{ helper_prefix }}: Power monitor {{ current_power }}W → brightness {{ detected_brightness }}"
              level: info

      # BUTTON PRESS SIMULATION (from Node-RED brightness change logic)
      - conditions:
          - condition: template
            value_template: "{{ trigger_id == 'brightness_control_trigger' }}"
        sequence:
          - service: system_log.write
            data:
              message: "{{ helper_prefix }}: BUTTON SIMULATION TRIGGERED - Target: {{ current_brightness }}, Current Level: {{ current_level }}"
              level: info
          - variables:
              desired_level: "{{ current_brightness | int }}"
              
              # Determine current state - use power reading if recent, otherwise use stored level
              power_based_level: >
                {% if current_power >= 0 and current_power <= (threshold_0 | float) %}
                  0
                {% elif current_power > (threshold_0 | float) and current_power <= (threshold_1 | float) %}
                  1
                {% elif current_power > (threshold_1 | float) and current_power <= (threshold_2 | float) %}
                  2
                {% elif current_power > (threshold_2 | float) and current_power <= (threshold_3 | float) %}
                  3
                {% else %}
                  null
                {% endif %}
              
              # Use power-based level if available, otherwise use current detected level
              estimated_current: >
                {% if current_switch_state == 'off' %}
                  0
                {% elif power_based_level is not none %}
                  {{ power_based_level }}
                {% else %}
                  {{ current_level }}
                {% endif %}
              
              # Calculate button presses needed
              # Hardware: ON→Level 3, then cycles 3→2→1→3→2→1...
              # Examples: 0→1: ON (3) + 2 cycles (3→2→1), 0→2: ON (3) + 1 cycle (3→2), 0→3: ON (3) + 0 cycles
              button_presses: >
                {% set current = estimated_current | int %}
                {% set desired = desired_level %}
                {% if desired == 0 %}
                  0
                {% elif current == 0 %}
                  {% if desired == 1 %}2{% elif desired == 2 %}1{% elif desired == 3 %}0{% else %}0{% endif %}
                {% elif current == 1 %}
                  {% if desired == 2 %}2{% elif desired == 3 %}1{% else %}0{% endif %}
                {% elif current == 2 %}
                  {% if desired == 1 %}1{% elif desired == 3 %}2{% else %}0{% endif %}
                {% elif current == 3 %}
                  {% if desired == 1 %}2{% elif desired == 2 %}1{% else %}0{% endif %}
                {% else %}0{% endif %}
              
              needs_turn_off: "{{ desired_level == 0 }}"
              is_currently_off: "{{ current_switch_state == 'off' or estimated_current == 0 }}"

          - service: system_log.write
            data:
              message: "{{ helper_prefix }}: CONTROL PLAN - Estimated: {{ estimated_current }}, Current: {{ current_level }}, Target: {{ desired_level }}, Presses: {{ button_presses }}, Switch: {{ current_switch_state }}, TurnOff: {{ needs_turn_off }}"
              level: info

          - choose:
              # Turn off case
              - conditions:
                  - condition: template
                    value_template: "{{ needs_turn_off }}"
                sequence:
                  - service: switch.turn_off
                    target:
                      entity_id: !input aquarium_switch
                  - service: system_log.write
                    data:
                      message: "{{ helper_prefix }}: TURNED OFF - Target brightness was 0"
                      level: info
              
              # Button press case - light needs to be on (level > 0)
              - conditions:
                  - condition: template
                    value_template: "{{ desired_level > 0 }}"
                sequence:
                  # Turn on first if currently off
                  - if:
                      - condition: template
                        value_template: "{{ is_currently_off }}"
                    then:
                      - service: switch.turn_on
                        target:
                          entity_id: !input aquarium_switch
                      - service: system_log.write
                        data:
                          message: "{{ helper_prefix }}: TURNED ON - Light was off, now at level 3"
                          level: warning
                      - delay:
                          milliseconds: "{{ initial_on_delay }}"
                  
                  # Execute rapid on/off cycles to reach desired level (if needed)
                  - if:
                      - condition: template
                        value_template: "{{ button_presses > 0 }}"
                    then:
                      - service: system_log.write
                        data:
                          message: "{{ helper_prefix }}: CYCLING - Executing {{ button_presses }} rapid on/off cycles"
                          level: warning
                      
                      - repeat:
                          count: "{{ button_presses }}"
                          sequence:
                            - service: system_log.write
                              data:
                                message: "{{ helper_prefix }}: CYCLE {{ repeat.index }}/{{ button_presses }} - Turning OFF"
                                level: debug
                            - service: switch.turn_off
                              target:
                                entity_id: !input aquarium_switch
                            - delay:
                                milliseconds: "{{ cycle_off_delay }}"
                            - service: system_log.write
                              data:
                                message: "{{ helper_prefix }}: CYCLE {{ repeat.index }}/{{ button_presses }} - Turning ON"
                                level: debug
                            - service: switch.turn_on
                              target:
                                entity_id: !input aquarium_switch
                            - delay:
                                milliseconds: "{{ cycle_on_delay }}"
                    else:
                      - service: system_log.write
                        data:
                          message: "{{ helper_prefix }}: NO CYCLING - Already at desired level {{ desired_level }}"
                          level: debug
                  
                  - service: system_log.write
                    data:
                      message: "{{ helper_prefix }}: CYCLING COMPLETE - Should now be at level {{ desired_level }}"
                      level: info

          # Wait for light to stabilize 
          - delay:
              milliseconds: "{{ stabilization_delay }}"
          
          # Check actual power level after stabilization and validate against expected
          - variables:
              final_brightness_input: "{{ states(brightness_input) | float(0) }}"
              brightness_changed_during_transition: "{{ final_brightness_input != current_brightness }}"
              
              # Read actual power after stabilization
              stabilized_power: "{{ states(power_input) | float(0) }}"
              stabilized_switch_state: "{{ states(switch_input) }}"
              
              # Determine what level the power reading indicates
              power_detected_level: >
                {% if stabilized_switch_state == 'off' %}
                  0
                {% elif stabilized_power >= 0 and stabilized_power <= (threshold_0 | float) %}
                  0
                {% elif stabilized_power > (threshold_0 | float) and stabilized_power <= (threshold_1 | float) %}
                  1
                {% elif stabilized_power > (threshold_1 | float) and stabilized_power <= (threshold_2 | float) %}
                  2
                {% elif stabilized_power > (threshold_2 | float) and stabilized_power <= (threshold_3 | float) %}
                  3
                {% else %}
                  3
                {% endif %}
              
              # Our expected level should be the desired_level (what we tried to achieve)
              expected_level: "{{ desired_level }}"
              level_mismatch: "{{ power_detected_level != expected_level }}"
          
          - service: system_log.write
            data:
              message: "{{ helper_prefix }}: POST-STABILIZATION - Expected: {{ expected_level }}, Power reading: {{ stabilized_power }}W=Level{{ power_detected_level }}, Mismatch: {{ level_mismatch }}, Input changed: {{ brightness_changed_during_transition }}"
              level: debug
          
          # Log level mismatch if detected
          - if:
              - condition: template
                value_template: "{{ level_mismatch }}"
            then:
              - service: system_log.write
                data:
                  message: "{{ helper_prefix }}: LEVEL MISMATCH DETECTED - Expected Level {{ expected_level }} but power {{ stabilized_power }}W indicates Level {{ power_detected_level }}. Trusting power meter reading."
                  level: warning
          
          # If brightness input changed during transition, perform additional button simulation
          - if:
              - condition: template
                value_template: "{{ brightness_changed_during_transition }}"
            then:
              - service: system_log.write
                data:
                  message: "{{ helper_prefix }}: INPUT CHANGED DURING TRANSITION - Performing additional change to reach new target: {{ final_brightness_input }}"
                  level: warning
              
              # Wait a moment to avoid rapid cycling
              - delay:
                  seconds: 1
              
              # Calculate additional button presses needed for the new target
              - variables:
                  new_desired_level: "{{ final_brightness_input | int }}"
                  
                  # Use the actual detected level from power meter (not expected level)
                  actual_current_level: "{{ power_detected_level }}"
                  
                  additional_button_presses: >
                    {% set current = actual_current_level | int %}
                    {% set desired = new_desired_level %}
                    {% if desired == 0 %}
                      0
                    {% elif current == 0 %}
                      {% if desired == 1 %}2{% elif desired == 2 %}1{% elif desired == 3 %}0{% else %}0{% endif %}
                    {% elif current == 1 %}
                      {% if desired == 2 %}2{% elif desired == 3 %}1{% else %}0{% endif %}
                    {% elif current == 2 %}
                      {% if desired == 1 %}1{% elif desired == 3 %}2{% else %}0{% endif %}
                    {% elif current == 3 %}
                      {% if desired == 1 %}2{% elif desired == 2 %}1{% else %}0{% endif %}
                    {% else %}0{% endif %}
                  
                  additional_needs_turn_off: "{{ new_desired_level == 0 }}"
              
              - service: system_log.write
                data:
                  message: "{{ helper_prefix }}: ADDITIONAL CHANGE PLAN - Actual Current: {{ actual_current_level }} (from power meter), New Target: {{ new_desired_level }}, Additional Presses: {{ additional_button_presses }}"
                  level: info
              
              # Execute additional changes
              - choose:
                  # Turn off case
                  - conditions:
                      - condition: template
                        value_template: "{{ additional_needs_turn_off }}"
                    sequence:
                      - service: switch.turn_off
                        target:
                          entity_id: !input aquarium_switch
                      - service: system_log.write
                        data:
                          message: "{{ helper_prefix }}: ADDITIONAL CHANGE - TURNED OFF"
                          level: info
                  
                  # Additional button presses case
                  - conditions:
                      - condition: template
                        value_template: "{{ additional_button_presses > 0 and new_desired_level > 0 }}"
                    sequence:
                      - service: system_log.write
                        data:
                          message: "{{ helper_prefix }}: ADDITIONAL CYCLING - Executing {{ additional_button_presses }} more cycles"
                          level: warning
                      
                      - repeat:
                          count: "{{ additional_button_presses }}"
                          sequence:
                            - service: system_log.write
                              data:
                                message: "{{ helper_prefix }}: ADDITIONAL CYCLE {{ repeat.index }}/{{ additional_button_presses }} - OFF"
                                level: warning
                            - service: switch.turn_off
                              target:
                                entity_id: !input aquarium_switch
                            - delay:
                                milliseconds: "{{ cycle_off_delay }}"
                            - service: system_log.write
                              data:
                                message: "{{ helper_prefix }}: ADDITIONAL CYCLE {{ repeat.index }}/{{ additional_button_presses }} - ON"
                                level: warning
                            - service: switch.turn_on
                              target:
                                entity_id: !input aquarium_switch
                            - delay:
                                milliseconds: "{{ cycle_on_delay }}"
              
              # Final stabilization
              - delay:
                  milliseconds: "{{ stabilization_delay }}"
              
              - service: system_log.write
                data:
                  message: "{{ helper_prefix }}: ADDITIONAL CHANGE COMPLETE - Final target {{ new_desired_level }} reached"
                  level: info
            else:
              - service: system_log.write
                data:
                  message: "{{ helper_prefix }}: Brightness change {{ current_level }} → {{ desired_level }} ({{ button_presses }} presses) - COMPLETE"
                  level: info

      # PERIODIC VALIDATION - Check state alignment every minute (respecting quiet periods)
      - conditions:
          - condition: template
            value_template: "{{ trigger_id == 'periodic_validation' }}"
        sequence:
          - service: system_log.write
            data:
              message: "{{ helper_prefix }}: PERIODIC VALIDATION - Time since last run: {{ (time_since_last_run / 1000) | round(0) }}s, Required quiet period: {{ (validation_quiet_period / 1000) | round(0) }}s"
              level: info
          
          # Only proceed if enough time has passed since last automation run
          - condition: template
            value_template: "{{ time_since_last_run > validation_quiet_period }}"
          
          - service: system_log.write
            data:
              message: "{{ helper_prefix }}: PERIODIC VALIDATION ACTIVE - Power: {{ current_power }}W, Input: {{ current_brightness }}, Current Level: {{ current_level }}"
              level: warning
          
          - variables:
              validation_detected_brightness: >
                {% if current_power >= 0 and current_power < threshold_0 %}
                  0
                {% elif current_power >= threshold_0 and current_power <= threshold_1 %}
                  1
                {% elif current_power > threshold_1 and current_power <= threshold_2 %}
                  2
                {% elif current_power > threshold_2 and current_power <= threshold_3 %}
                  3
                {% else %}
                  null
                {% endif %}
          
          - service: system_log.write
            data:
              message: "{{ helper_prefix }}: PERIODIC VALIDATION ANALYSIS - {{ current_power }}W detected as level {{ validation_detected_brightness }}, input setting: {{ current_brightness }}"
              level: info
          
          # Log mismatch if detected
          - if:
              - condition: template
                value_template: "{{ validation_detected_brightness is not none and validation_detected_brightness != current_brightness }}"
            then:
              - service: system_log.write
                data:
                  message: "{{ helper_prefix }}: PERIODIC VALIDATION MISMATCH - Power {{ current_power }}W=Level{{ validation_detected_brightness }}, but Input={{ current_brightness }}. Consider manual correction."
                  level: warning
            else:
              - service: system_log.write
                data:
                  message: "{{ helper_prefix }}: PERIODIC VALIDATION OK - State aligned: Level {{ validation_detected_brightness }}"
                  level: info

    # CATCH-ALL: Log unhandled triggers
    default:
      - service: system_log.write
        data:
          message: "{{ switch_input.split('.')[1] }}: UNHANDLED TRIGGER - ID: {{ trigger_id }}, no matching conditions"
          level: warning

mode: single
max_exceeded: silent