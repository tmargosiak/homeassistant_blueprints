blueprint:
  name: "Aquarium Smart Lighting Control"
  description: >
    Aquarium lighting control with power monitoring and brightness level control
    via button press simulation. Automatically detects current light level from
    power consumption with periodic validation.
    
    SETUP: Create input number helper for brightness control (min:0, max:3, step:1)
    then use this blueprint with your smart socket and power sensor.
  
  domain: automation
  
  input:
    aquarium_switch:
      name: "Aquarium Smart Socket"
      description: "Smart socket that controls the aquarium lights and monitors power consumption"
      selector:
        entity:
          domain: switch
    
    power_sensor:
      name: "Power Consumption Sensor"
      description: "Sensor that monitors the power consumption of the aquarium lights (usually from the smart socket)"
      selector:
        entity:
          domain: sensor
          device_class: power
    
    brightness_control:
      name: "Brightness Control Input"
      description: "Input number that controls light intensity (0=off, 1=low, 2=medium, 3=high). Create this in Helpers first."
      selector:
        entity:
          domain: input_number

variables:
  # Power thresholds (based on original Node-RED values)
  threshold_0: 0.5    # 0-0.5W = Level 0 (off)
  threshold_1: 5.0    # 0.5-5W = Level 1 (low)
  threshold_2: 9.0    # 6-9W = Level 2 (medium)
  threshold_3: 15.0   # 11-15W = Level 3 (high)
  
  # Timing configuration (all delays in milliseconds)
  initial_on_delay: 1000            # Wait after turning on before cycling starts
  cycle_off_delay: 500              # Wait after turning off during each cycle  
  cycle_on_delay: 500               # Wait after turning on during each cycle
  stabilization_delay: 60000        # Wait for light stabilization after all changes complete (60 seconds)
  validation_quiet_period: 120000   # Milliseconds to wait after state change before allowing periodic validation (2 minutes)
  


trigger:
  # Power monitoring trigger
  - platform: state
    entity_id: !input power_sensor
    id: "power_changed"
  
  # Brightness control trigger with delay (for button simulation)
  # Note: This delay cannot use variables - must be hardcoded in trigger
  - platform: state
    entity_id: !input brightness_control
    for:
      seconds: 2
    id: "brightness_control_trigger"
  
  # Home Assistant start
  - platform: homeassistant
    event: start
    id: "ha_start"
  
  # Periodic validation (every minute) - validates state when no recent changes
  - platform: time_pattern
    minutes: "*"
    id: "periodic_validation"

condition: []

action:
  - variables:
      trigger_id: "{{ trigger.id | default('unknown') }}"
      brightness_input: !input brightness_control
      power_input: !input power_sensor  
      switch_input: !input aquarium_switch
      current_brightness: "{{ states(brightness_input) | float(0) }}"
      current_power: "{{ states(power_input) | float(0) }}"
      current_switch_state: "{{ states(switch_input) }}"

      # Create unique prefix for logging
      helper_prefix: "{{ switch_input.split('.')[1] }}"
      
      # Use this automation's last_triggered to determine quiet period
      # If automation never ran button simulation, allow validation immediately
      last_automation_run: "{{ this.attributes.last_triggered if this.attributes.last_triggered else '1970-01-01T00:00:00+00:00' }}"
      time_since_last_run: >
        {% set last_run = as_timestamp(last_automation_run) %}
        {% set now_time = now().timestamp() %}
        {{ ((now_time - last_run) * 1000) | int }}
      
      # Always estimate level from power reading - no persistent state needed
      current_level: >
        {% set power = current_power %}
        {% set switch_state = current_switch_state %}
        {% if switch_state == 'off' %}
          0
        {% elif power >= 0 and power <= (threshold_0 | float) %}
          0
        {% elif power > (threshold_0 | float) and power <= (threshold_1 | float) %}
          1
        {% elif power > (threshold_1 | float) and power <= (threshold_2 | float) %}
          2
        {% elif power > (threshold_2 | float) and power <= (threshold_3 | float) %}
          3
        {% else %}
          3
        {% endif %}
      


  # TRACE: Log every automation trigger
  - service: system_log.write
    data:
      message: "{{ helper_prefix }}: AUTOMATION TRIGGERED - ID: {{ trigger_id }}, Brightness: {{ current_brightness }}, Power: {{ current_power }}W, Switch: {{ current_switch_state }}, Current Level: {{ current_level }}"
      level: info

  # Route to appropriate logic based on trigger
  - choose:
      # INITIALIZATION - Log current state detected from power reading
      - conditions:
          - condition: template
            value_template: "{{ trigger_id == 'ha_start' }}"
        sequence:
          - service: system_log.write
            data:
              message: "{{ helper_prefix }}: INITIALIZATION - Current state detected: Level {{ current_level }} from {{ current_power }}W"
              level: warning



      # POWER MONITORING (from Node-RED power sensor logic)
      - conditions:
          - condition: template
            value_template: "{{ trigger_id in ['power_changed', 'ha_start'] }}"
        sequence:
          - service: system_log.write
            data:
              message: "{{ helper_prefix }}: POWER MONITORING TRIGGERED - Power: {{ current_power }}W, Input: {{ current_brightness }}, Current Level: {{ current_level }}, Time since last run: {{ (time_since_last_run / 1000) | round(0) }}s"
              level: info
          
          # Skip power monitoring if too soon after button simulation (within stabilization period)
          - if:
              - condition: template
                value_template: "{{ trigger_id == 'power_changed' and time_since_last_run < stabilization_delay }}"
            then:
              - service: system_log.write
                data:
                  message: "{{ helper_prefix }}: POWER MONITORING SKIPPED - Only {{ (time_since_last_run / 1000) | round(0) }}s since last button simulation, waiting {{ (stabilization_delay / 1000) | round(0) }}s for stabilization"
                  level: info
              - stop: ""
          - variables:
              detected_brightness: >
                {%- if current_switch_state == 'off' -%}0
                {%- elif current_power <= threshold_0 -%}0
                {%- elif current_power <= threshold_1 -%}1
                {%- elif current_power <= threshold_2 -%}2
                {%- elif current_power <= threshold_3 -%}3
                {%- else -%}3{%- endif -%}
          
          - service: system_log.write
            data:
              message: "{{ helper_prefix }}: POWER ANALYSIS - {{ current_power }}W detected as level {{ detected_brightness }}, current setting: {{ current_brightness }}"
              level: info
          
          - condition: template
            value_template: "{{ detected_brightness is not none and detected_brightness != current_brightness }}"
          
          - service: system_log.write
            data:
              message: "{{ helper_prefix }}: BRIGHTNESS MISMATCH - Power {{ current_power }}W=Level{{ detected_brightness }}, Input={{ current_brightness }}, Current Level={{ current_level }}"
              level: warning
          
          # DISABLED: Auto-update of brightness input to prevent feedback loops
          # - service: input_number.set_value
          #   target:
          #     entity_id: !input brightness_control
          #   data:
          #     value: "{{ detected_brightness }}"
          
          - service: system_log.write
            data:
              message: "{{ helper_prefix }}: Power monitor {{ current_power }}W → brightness {{ detected_brightness }}"
              level: info

      # BUTTON PRESS SIMULATION (from Node-RED brightness change logic)
      - conditions:
          - condition: template
            value_template: "{{ trigger_id == 'brightness_control_trigger' }}"
        sequence:
          - service: system_log.write
            data:
              message: "{{ helper_prefix }}: BUTTON SIMULATION TRIGGERED - Target: {{ current_brightness }}, Current Level: {{ current_level }}"
              level: info
          - variables:
              desired_level: "{{ current_brightness | int }}"
              
              # Determine current state - use power reading if recent, otherwise use stored level
              power_based_level: >
                {% if current_power >= 0 and current_power <= (threshold_0 | float) %}
                  0
                {% elif current_power > (threshold_0 | float) and current_power <= (threshold_1 | float) %}
                  1
                {% elif current_power > (threshold_1 | float) and current_power <= (threshold_2 | float) %}
                  2
                {% elif current_power > (threshold_2 | float) and current_power <= (threshold_3 | float) %}
                  3
                {% else %}
                  null
                {% endif %}
              
              # Use power-based level if available, otherwise use current detected level  
              estimated_current: >
                {%- if current_switch_state == 'off' -%}0
                {%- elif power_based_level is not none -%}{{ power_based_level }}
                {%- else -%}{{ current_level }}{%- endif -%}
              
              # Calculate button presses needed (using lookup table for conciseness)
              # Hardware: ON→Level 3, then cycles 3→2→1→3→2→1...
              button_presses: >
                {%- set lookup = {'0->1':2,'0->2':1,'0->3':0,'1->2':2,'1->3':1,'1->0':0,'2->1':1,'2->3':2,'2->0':0,'3->1':2,'3->2':1,'3->0':0} -%}
                {{ lookup.get((estimated_current|int)~'->'~desired_level, 0) }}
              
              needs_turn_off: "{{ desired_level == 0 }}"
              is_currently_off: "{{ current_switch_state == 'off' or estimated_current == 0 }}"

          - service: system_log.write
            data:
              message: "{{ helper_prefix }}: CONTROL PLAN - Estimated: {{ estimated_current }}, Current: {{ current_level }}, Target: {{ desired_level }}, Presses: {{ button_presses }}, Switch: {{ current_switch_state }}, TurnOff: {{ needs_turn_off }}"
              level: info

          - choose:
              # Turn off case
              - conditions:
                  - condition: template
                    value_template: "{{ needs_turn_off }}"
                sequence:
                  - service: switch.turn_off
                    target:
                      entity_id: !input aquarium_switch
                  - service: system_log.write
                    data:
                      message: "{{ helper_prefix }}: TURNED OFF - Target brightness was 0"
                      level: info
              
              # Button press case - light needs to be on (level > 0)
              - conditions:
                  - condition: template
                    value_template: "{{ desired_level > 0 }}"
                sequence:
                  # Turn on first if currently off
                  - if:
                      - condition: template
                        value_template: "{{ is_currently_off }}"
                    then:
                      - service: switch.turn_on
                        target:
                          entity_id: !input aquarium_switch
                      - service: system_log.write
                        data:
                          message: "{{ helper_prefix }}: TURNED ON - Light was off, now at level 3"
                          level: warning
                      - delay:
                          milliseconds: "{{ initial_on_delay }}"
                  
                  # Execute rapid on/off cycles to reach desired level (if needed)
                  - if:
                      - condition: template
                        value_template: "{{ button_presses > 0 }}"
                    then:
                      - service: system_log.write
                        data:
                          message: "{{ helper_prefix }}: CYCLING - Executing {{ button_presses }} rapid on/off cycles"
                          level: warning
                      
                      - repeat:
                          count: "{{ button_presses }}"
                          sequence:
                            - service: system_log.write
                              data:
                                message: "{{ helper_prefix }}: CYCLE {{ repeat.index }}/{{ button_presses }} - Turning OFF"
                                level: debug
                            - service: switch.turn_off
                              target:
                                entity_id: !input aquarium_switch
                            - delay:
                                milliseconds: "{{ cycle_off_delay }}"
                            - service: system_log.write
                              data:
                                message: "{{ helper_prefix }}: CYCLE {{ repeat.index }}/{{ button_presses }} - Turning ON"
                                level: debug
                            - service: switch.turn_on
                              target:
                                entity_id: !input aquarium_switch
                            - delay:
                                milliseconds: "{{ cycle_on_delay }}"
                    else:
                      - service: system_log.write
                        data:
                          message: "{{ helper_prefix }}: NO CYCLING - Already at desired level {{ desired_level }}"
                          level: debug
                  
                  - service: system_log.write
                    data:
                      message: "{{ helper_prefix }}: CYCLING COMPLETE - Should now be at level {{ desired_level }}"
                      level: info

          # Wait for light to stabilize (60 seconds)
          - delay:
              milliseconds: "{{ stabilization_delay }}"
          
          - service: system_log.write
            data:
              message: "{{ helper_prefix }}: STABILIZATION COMPLETE - Reading power after {{ (stabilization_delay / 1000) | round(0) }} seconds"
              level: info
          
          # Check actual power level after stabilization and validate against expected
          - variables:
              final_brightness_input: "{{ states(brightness_input) | float(0) }}"
              brightness_changed_during_transition: "{{ final_brightness_input != current_brightness }}"
              
              # Read actual power after stabilization - force a fresh reading
              stabilized_power: "{{ states(power_input) | float(0) }}"
              stabilized_switch_state: "{{ states(switch_input) }}"
              
              # Determine what level the power reading indicates
              power_detected_level: >
                {% if stabilized_switch_state == 'off' %}
                  0
                {% elif stabilized_power >= 0 and stabilized_power <= (threshold_0 | float) %}
                  0
                {% elif stabilized_power > (threshold_0 | float) and stabilized_power <= (threshold_1 | float) %}
                  1
                {% elif stabilized_power > (threshold_1 | float) and stabilized_power <= (threshold_2 | float) %}
                  2
                {% elif stabilized_power > (threshold_2 | float) and stabilized_power <= (threshold_3 | float) %}
                  3
                {% else %}
                  3
                {% endif %}
              
              # Our expected level should be the desired_level (what we tried to achieve)
              expected_level: "{{ desired_level }}"
              level_mismatch: "{{ power_detected_level != expected_level }}"
          
          - service: system_log.write
            data:
              message: "{{ helper_prefix }}: POST-STABILIZATION - Expected: {{ expected_level }}, Power reading: {{ stabilized_power }}W=Level{{ power_detected_level }}, Mismatch: {{ level_mismatch }}, Input changed: {{ brightness_changed_during_transition }}"
              level: warning
          
          # Auto-correct level mismatch if detected
          - if:
              - condition: template
                value_template: "{{ level_mismatch }}"
            then:
              - service: system_log.write
                data:
                  message: "{{ helper_prefix }}: LEVEL MISMATCH DETECTED - Expected Level {{ expected_level }} but power {{ stabilized_power }}W indicates Level {{ power_detected_level }}. AUTO-CORRECTING..."
                  level: warning
              
              # Calculate correction button presses needed
              - variables:
                  correction_target: "{{ expected_level }}"
                  correction_current: "{{ power_detected_level }}"
                  correction_button_presses: >
                    {%- set lookup = {'0->1':2,'0->2':1,'0->3':0,'1->2':2,'1->3':1,'1->0':0,'2->1':1,'2->3':2,'2->0':0,'3->1':2,'3->2':1,'3->0':0} -%}
                    {{ lookup.get((correction_current|int)~'->'~correction_target, 0) }}
                  correction_needs_turn_off: "{{ correction_target == 0 }}"
              
              - service: system_log.write
                data:
                  message: "{{ helper_prefix }}: AUTO-CORRECTION PLAN - Current Level: {{ correction_current }}, Target Level: {{ correction_target }}, Button Presses: {{ correction_button_presses }}, Turn Off: {{ correction_needs_turn_off }}"
                  level: warning
              
              # Execute correction
              - choose:
                  # Turn off case
                  - conditions:
                      - condition: template
                        value_template: "{{ correction_needs_turn_off }}"
                    sequence:
                      - service: switch.turn_off
                        target:
                          entity_id: !input aquarium_switch
                      - service: system_log.write
                        data:
                          message: "{{ helper_prefix }}: AUTO-CORRECTION - TURNED OFF to reach Level 0"
                          level: warning
                  
                  # Button press correction case
                  - conditions:
                      - condition: template
                        value_template: "{{ correction_button_presses > 0 and correction_target > 0 }}"
                    sequence:
                      - service: system_log.write
                        data:
                          message: "{{ helper_prefix }}: AUTO-CORRECTION CYCLING - Executing {{ correction_button_presses }} cycles to reach Level {{ correction_target }}"
                          level: warning
                      
                      - repeat:
                          count: "{{ correction_button_presses }}"
                          sequence:
                            - service: system_log.write
                              data:
                                message: "{{ helper_prefix }}: CORRECTION CYCLE {{ repeat.index }}/{{ correction_button_presses }} - OFF"
                                level: warning
                            - service: switch.turn_off
                              target:
                                entity_id: !input aquarium_switch
                            - delay:
                                milliseconds: "{{ cycle_off_delay }}"
                            - service: system_log.write
                              data:
                                message: "{{ helper_prefix }}: CORRECTION CYCLE {{ repeat.index }}/{{ correction_button_presses }} - ON"
                                level: warning
                            - service: switch.turn_on
                              target:
                                entity_id: !input aquarium_switch
                            - delay:
                                milliseconds: "{{ cycle_on_delay }}"
                  
                # No correction needed
                default:
                  - service: system_log.write
                    data:
                      message: "{{ helper_prefix }}: AUTO-CORRECTION - No button presses needed, already at target level"
                      level: info
              
              # Wait for stabilization after correction
              - delay:
                  milliseconds: "{{ stabilization_delay }}"
              
              # Verify correction was successful
              - variables:
                  corrected_power: "{{ states(power_input) | float(0) }}"
                  corrected_switch_state: "{{ states(switch_input) }}"
                  corrected_level: >
                    {% if corrected_switch_state == 'off' %}
                      0
                    {% elif corrected_power >= 0 and corrected_power <= (threshold_0 | float) %}
                      0
                    {% elif corrected_power > (threshold_0 | float) and corrected_power <= (threshold_1 | float) %}
                      1
                    {% elif corrected_power > (threshold_1 | float) and corrected_power <= (threshold_2 | float) %}
                      2
                    {% elif corrected_power > (threshold_2 | float) and corrected_power <= (threshold_3 | float) %}
                      3
                    {% else %}
                      3
                    {% endif %}
                  correction_successful: "{{ corrected_level == expected_level }}"
              
              - service: system_log.write
                data:
                  message: "{{ helper_prefix }}: AUTO-CORRECTION RESULT - Target: Level {{ expected_level }}, Final: {{ corrected_power }}W=Level{{ corrected_level }}, Success: {{ correction_successful }}"
                  level: warning
          
          # If brightness input changed during transition, perform additional button simulation
          - if:
              - condition: template
                value_template: "{{ brightness_changed_during_transition }}"
            then:
              - service: system_log.write
                data:
                  message: "{{ helper_prefix }}: INPUT CHANGED DURING TRANSITION - Performing additional change to reach new target: {{ final_brightness_input }}"
                  level: warning
              
              # Wait a moment to avoid rapid cycling
              - delay:
                  seconds: 1
              
              # Calculate additional button presses needed for the new target
              - variables:
                  new_desired_level: "{{ final_brightness_input | int }}"
                  
                  # Use the actual detected level from power meter (not expected level)
                  actual_current_level: "{{ power_detected_level }}"
                  
                  additional_button_presses: >
                    {%- set lookup = {'0->1':2,'0->2':1,'0->3':0,'1->2':2,'1->3':1,'1->0':0,'2->1':1,'2->3':2,'2->0':0,'3->1':2,'3->2':1,'3->0':0} -%}
                    {{ lookup.get((actual_current_level|int)~'->'~new_desired_level, 0) }}
                  
                  additional_needs_turn_off: "{{ new_desired_level == 0 }}"
              
              - service: system_log.write
                data:
                  message: "{{ helper_prefix }}: ADDITIONAL CHANGE PLAN - Actual Current: {{ actual_current_level }} (from power meter), New Target: {{ new_desired_level }}, Additional Presses: {{ additional_button_presses }}"
                  level: info
              
              # Execute additional changes
              - choose:
                  # Turn off case
                  - conditions:
                      - condition: template
                        value_template: "{{ additional_needs_turn_off }}"
                    sequence:
                      - service: switch.turn_off
                        target:
                          entity_id: !input aquarium_switch
                      - service: system_log.write
                        data:
                          message: "{{ helper_prefix }}: ADDITIONAL CHANGE - TURNED OFF"
                          level: info
                  
                  # Additional button presses case
                  - conditions:
                      - condition: template
                        value_template: "{{ additional_button_presses > 0 and new_desired_level > 0 }}"
                    sequence:
                      - service: system_log.write
                        data:
                          message: "{{ helper_prefix }}: ADDITIONAL CYCLING - Executing {{ additional_button_presses }} more cycles"
                          level: warning
                      
                      - repeat:
                          count: "{{ additional_button_presses }}"
                          sequence:
                            - service: system_log.write
                              data:
                                message: "{{ helper_prefix }}: ADDITIONAL CYCLE {{ repeat.index }}/{{ additional_button_presses }} - OFF"
                                level: warning
                            - service: switch.turn_off
                              target:
                                entity_id: !input aquarium_switch
                            - delay:
                                milliseconds: "{{ cycle_off_delay }}"
                            - service: system_log.write
                              data:
                                message: "{{ helper_prefix }}: ADDITIONAL CYCLE {{ repeat.index }}/{{ additional_button_presses }} - ON"
                                level: warning
                            - service: switch.turn_on
                              target:
                                entity_id: !input aquarium_switch
                            - delay:
                                milliseconds: "{{ cycle_on_delay }}"
              
              # Final stabilization for additional changes
              - delay:
                  milliseconds: "{{ stabilization_delay }}"
              
              # Final power reading after additional changes
              - variables:
                  final_stabilized_power: "{{ states(power_input) | float(0) }}"
                  final_power_detected_level: >
                    {% if states(switch_input) == 'off' %}
                      0
                    {% elif final_stabilized_power >= 0 and final_stabilized_power <= (threshold_0 | float) %}
                      0
                    {% elif final_stabilized_power > (threshold_0 | float) and final_stabilized_power <= (threshold_1 | float) %}
                      1
                    {% elif final_stabilized_power > (threshold_1 | float) and final_stabilized_power <= (threshold_2 | float) %}
                      2
                    {% elif final_stabilized_power > (threshold_2 | float) and final_stabilized_power <= (threshold_3 | float) %}
                      3
                    {% else %}
                      3
                    {% endif %}
              
              - service: system_log.write
                data:
                  message: "{{ helper_prefix }}: ADDITIONAL CHANGE COMPLETE - Final target {{ new_desired_level }}, Final power: {{ final_stabilized_power }}W=Level{{ final_power_detected_level }}"
                  level: info
            else:
              - service: system_log.write
                data:
                  message: "{{ helper_prefix }}: Brightness change {{ current_level }} → {{ desired_level }} ({{ button_presses }} presses) - COMPLETE"
                  level: info

      # PERIODIC VALIDATION - Check state alignment every minute (respecting quiet periods)
      - conditions:
          - condition: template
            value_template: "{{ trigger_id == 'periodic_validation' }}"
        sequence:
          - service: system_log.write
            data:
              message: "{{ helper_prefix }}: PERIODIC VALIDATION - Time since last run: {{ (time_since_last_run / 1000) | round(0) }}s, Required quiet period: {{ (validation_quiet_period / 1000) | round(0) }}s"
              level: info
          
          # Only proceed if enough time has passed since last automation run
          - condition: template
            value_template: "{{ time_since_last_run > validation_quiet_period }}"
          
          - service: system_log.write
            data:
              message: "{{ helper_prefix }}: PERIODIC VALIDATION ACTIVE - Power: {{ current_power }}W, Input: {{ current_brightness }}, Current Level: {{ current_level }}"
              level: warning
          
          - variables:
              validation_detected_brightness: >
                {%- if current_switch_state == 'off' -%}0
                {%- elif current_power <= threshold_0 -%}0
                {%- elif current_power <= threshold_1 -%}1
                {%- elif current_power <= threshold_2 -%}2
                {%- elif current_power <= threshold_3 -%}3
                {%- else -%}3{%- endif -%}
          
          - service: system_log.write
            data:
              message: "{{ helper_prefix }}: PERIODIC VALIDATION ANALYSIS - {{ current_power }}W detected as level {{ validation_detected_brightness }}, input setting: {{ current_brightness }}"
              level: info
          
          # Auto-correct mismatch if detected during periodic validation
          - if:
              - condition: template
                value_template: "{{ validation_detected_brightness is not none and validation_detected_brightness != current_brightness }}"
            then:
              - service: system_log.write
                data:
                  message: "{{ helper_prefix }}: PERIODIC VALIDATION MISMATCH - Power {{ current_power }}W=Level{{ validation_detected_brightness }}, but Input={{ current_brightness }}. AUTO-CORRECTING..."
                  level: warning
              
              # Calculate correction for periodic validation
              - variables:
                  periodic_correction_target: "{{ current_brightness | int }}"
                  periodic_correction_current: "{{ validation_detected_brightness }}"
                  periodic_correction_button_presses: >
                    {%- set lookup = {'0->1':2,'0->2':1,'0->3':0,'1->2':2,'1->3':1,'1->0':0,'2->1':1,'2->3':2,'2->0':0,'3->1':2,'3->2':1,'3->0':0} -%}
                    {{ lookup.get((periodic_correction_current|int)~'->'~periodic_correction_target, 0) }}
                  periodic_correction_needs_turn_off: "{{ periodic_correction_target == 0 }}"
              
              - service: system_log.write
                data:
                  message: "{{ helper_prefix }}: PERIODIC AUTO-CORRECTION - Current: Level {{ periodic_correction_current }}, Target: Level {{ periodic_correction_target }}, Presses: {{ periodic_correction_button_presses }}"
                  level: warning
              
              # Execute periodic correction
              - choose:
                  # Turn off case
                  - conditions:
                      - condition: template
                        value_template: "{{ periodic_correction_needs_turn_off }}"
                    sequence:
                      - service: switch.turn_off
                        target:
                          entity_id: !input aquarium_switch
                      - service: system_log.write
                        data:
                          message: "{{ helper_prefix }}: PERIODIC AUTO-CORRECTION - TURNED OFF"
                          level: warning
                  
                  # Button press correction case
                  - conditions:
                      - condition: template
                        value_template: "{{ periodic_correction_button_presses > 0 and periodic_correction_target > 0 }}"
                    sequence:
                      # Turn on first if currently off
                      - if:
                          - condition: template
                            value_template: "{{ current_switch_state == 'off' }}"
                        then:
                          - service: switch.turn_on
                            target:
                              entity_id: !input aquarium_switch
                          - service: system_log.write
                            data:
                              message: "{{ helper_prefix }}: PERIODIC AUTO-CORRECTION - TURNED ON first"
                              level: warning
                          - delay:
                              milliseconds: "{{ initial_on_delay }}"
                      
                      - service: system_log.write
                        data:
                          message: "{{ helper_prefix }}: PERIODIC AUTO-CORRECTION CYCLING - {{ periodic_correction_button_presses }} cycles"
                          level: warning
                      
                      - repeat:
                          count: "{{ periodic_correction_button_presses }}"
                          sequence:
                            - service: switch.turn_off
                              target:
                                entity_id: !input aquarium_switch
                            - delay:
                                milliseconds: "{{ cycle_off_delay }}"
                            - service: switch.turn_on
                              target:
                                entity_id: !input aquarium_switch
                            - delay:
                                milliseconds: "{{ cycle_on_delay }}"
                
                # No correction needed
                default:
                  - service: system_log.write
                    data:
                      message: "{{ helper_prefix }}: PERIODIC AUTO-CORRECTION - No action needed"
                      level: info
              
              - service: system_log.write
                data:
                  message: "{{ helper_prefix }}: PERIODIC AUTO-CORRECTION COMPLETE"
                  level: warning
            else:
              - service: system_log.write
                data:
                  message: "{{ helper_prefix }}: PERIODIC VALIDATION OK - State aligned: Level {{ validation_detected_brightness }}"
                  level: info

    # CATCH-ALL: Log unhandled triggers
    default:
      - service: system_log.write
        data:
          message: "{{ switch_input.split('.')[1] }}: UNHANDLED TRIGGER - ID: {{ trigger_id }}, no matching conditions"
          level: warning

mode: single
max_exceeded: silent